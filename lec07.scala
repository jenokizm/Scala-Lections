// Начало Пропущенный кусок (около 30 минут)
val left = right => right match{
       |			case left =>{
       code			code
		}
	}
val x = 4  => 4 match {
			x=>{
		}
	}

val (x, y) = p
val ((x1, y1), _) = getLine()
val line@(p1@(x1, y1), p2@(x2,y2)) = getLine()
val _::x::tail = List(5,7,9,12) x=7 tail=(9,12)
val Array(z, w) = getNumber()
Если образец не сопоставится, то произойдет исключение. Любой val или var всегда match семантически. 

Если функция или лямбда состоит только из match:
x => x match{
…
}
 В таком случае первую строку можно не писать.
lstP map {
	case (x,y) => x+y
}
lstP.map(x => x match{
	…
})

ООП
class <имя> [(список параметров главного конструктора)] 
{
…
}
По умолчанию все public. 
class Box( l: Int , w: Int, h:Int)
{
	val length = l;
	…
	//val volume = l*w*h
def volume = l*w*h – считать объем  при каждом обращении  == def volume() = l*w*h
}
// Конец Пропущенный кусок

class Box(...) {
    // Является аналогом перегрузки [] в C++
    // (не забываем про вызов массивов через ())
    // Нету ограничения на число параметров
    def apply(name:String)=???
    def apply(i:Int)=???

    // ? - тип данных "зависимый"
    // Последнее - то, что присваиваем, остальное имплекс
    def update(s:String, v:?)=?

}

val b1 = new Box(...)
// Вызовет неявно apply
b1("мячик") // b1.apply("мячик")
b1(4)
// Вызовется неявно update
b1("мячик") = new Ball(...)
b1("мячик", 0) = new Ball(...)

// Можно создавтаь объект с именем класса (имя класса и объекта в разных пространствах)
// Такой объект называется объект-компаньон
object Box {
    // apply в object!
    def apply(l:Int, w:Int) = new Box(l,w,1)
}
// new нету
val b2 = Box(2,3) // Вызоов apply у объекта с именем Box. Стоит обратить внимание, что такой метод может не иметь ничего общего с new
val b1 = new Box(...) //  Создание экземпляра класса


