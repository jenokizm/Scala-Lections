// Не интерпретируется ESC-последовательность
row"строка"
// Интерполяционная строка:
// s"
// в строку можно включать вычислимые выражение
val x = 5
s"x=$x" // Строка будет равна 5
// Всё что в скобках будет вычислено как значение
s"2*x=${2*x}"
// Также можно писать любой код, вызов объекта и т.д.
// Можно также придумывать свои модификатор (как s, row)

// Длина строки
"".length
// Если в строке записано регулярное выражение, то оно вычиляется
"".r
// Стандартный split, но если аргумент char, то будет служить как разделитель/и
"".split(c:char)
// и аналогично string
"".split(s:string)
// split возвращает массивы строк
//  Стоит заметить, что второй аргумент - это end, а не length
"".substring(start:Int)
"".substring(start:Int, end:Int)
// Будут включены 5,6,7 символ
"".substring(5,8)

// Индексация ("[n]") пишется круглыми скобками
str(2) // 3 символ в строке

// Идентификатором может быть:
// 1) То, что мы привыкли: начинается с буквы или подчеркивание и дальше следует последовательность символов/цифр;
// 2) Любой набор операторных символов; # + - ! < > * / ~ = : ? плюс Sm So наборы (>= - правильный идентификатор)
// 3) Составлен по первому правилу и по второму, но мешать нельзя
//      <1>_<2>
//      a_+
//      +_a - нельзя
// 4) Правильным идентификатором является любая строка, заключенаня в одинарные кавычки
//      'Привет мир'

// Не может быть правильным идентификатором:
// # - нельзя, но ## можно
// <%
// :>
// <:
// ()
// []
// {}
// ,
// ;
// ...

// Рабочий (не рекомендуемый) пример:
val ++ = 2
val +++ = 3
val z = ++ + +++

// ===
// Если есть объект с вызовом метода с 1 аргументом,
x.method(y)
// то это можно записать так
x method y
// Это нужно для следующего:
// + - это метод
(2).+(3) // == 5
2 + 3
// Операторов тут как таковых нету, операции - это методы

// ===
x.op(y)
x op y
y.op(x)
// Если имя идентификатора заканчивается на :, то объект y это параметр x
x + y => x.+(y)
x + :y => y.+:(x)

// Небольшая вырезка
// Последняя часть может быть не понятна (объяснение когда-нибудь потом)
readline split ' ' map {_.toInt}
(((readline) split ' ') map {_.toInt})
// ===

// Типы
// Для массивов нету такого понятия как массив, поэтому нету [], ()
Array[Int] // Это обобщенный тип
val arr:Array[Int] = new Array[Int](4)
val arr = Array.ofDim[Int](4) // 4 строки
val arr = Array.ofDim[Int](4,5) // 4 строки, 5 столбцов
// Ключевого слова new нету!
val arr = Array(2, x+1, 5) // Одномерный массив из трех элементов
val arr = Array(Array(1,2),Array(3,4)) // Двумерный массив из 4-х элементов
// Массив идущих подряд символов от start до end не включительно
val arr = Array.range(start, end)
// Загуглить эти два метода
val arr = Array.iterate //вызов iterate(start, len)(f)
//iterate - Returns an array containing repeated applications of a function to a start value.
val arr = Array.tabulate // Мощь!!!
//tabulate - Returns an array containing values of a given function over a range of integer values starting from 0.
// Заполнить каким-то значением (например, массив двоек)
val arr = Array.fill

// В Scala есть такой верхний тип, как Any
// Например, с помощью него можно сделать один массив из строки, double, Int и т.д.
// От него есть два наследника AnyVal (значащие типы) и AnyRef (ссылочные типы)

// От AnyVal дохрена наследников
// От AnyRef есть два наследника (их не увидеть)
// ScalaObject - неявный родитель всех объектных типов
// и он также является родителем для всех классов JDK и String
// Также для AnyVal можно написать своего наследника
// Для AnyRef есть также неявный наследник, называющийся null (значение) типа Null (тип)
// его экземпляр совместим с любой ссылкой

// Nothing является наследником AnyVal и AnyRef (он ниже, чем всё что вышенаписанное) 

// Очень много всего для коллекций (массивы, списки и т.д.), пример:
.head // первый элемент коллекции //голова
.tail // все остальные //хвост

